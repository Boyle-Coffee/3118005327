###  SimHash 与传统hash函数的区别

　　传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而 SimHash 本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。

　　我们主要解决的是文本相似度计算，要比较的是两个文章是否相识，当然我们降维生成了hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的 SimHash 就算把文章中的字符串变成 01  串也还是可以用于计算相似度的，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。

　　通过 SimHash 计算结果为：

　　1000010010101101**1**11111100000101011010001001111100001**0**0101**1**001011

　　1000010010101101**0**11111100000101011010001001111100001**1**0101**0**001011

　　通过传统hash计算为：

　　0001000001100110100111011011110

　　1010010001111111110010110011101

　　大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。

[ ](http://www.cnblogs.com/maybe2030/p/5203186.html#_labelTop)

###  SimHash 算法思想

　　假设我们有海量的文本数据，我们需要根据文本内容将它们进行去重。对于文本去重而言，目前有很多NLP相关的算法可以在很高精度上来解决，但是我们现在处理的是大数据维度上的文本去重，这就对算法的效率有着很高的要求。而局部敏感hash算法可以将原始的文本内容映射为数字（hash签名），而且较为相近的文本内容对应的hash签名也比较相近。 SimHash 算法是Google公司进行海量网页去重的高效算法，它通过将原始的文本映射为64位的二进制数字串，然后通过比较二进制数字串的差异进而来表示原始文本内容的差异。

[ ](http://www.cnblogs.com/maybe2030/p/5203186.html#_labelTop)

###  SimHash 流程实现

　　 SimHash 是由 Charikar 在2002年提出来的，本文为了便于理解尽量不使用数学公式，分为这几步：

　　（注：具体的事例摘自[Lanceyan](http://www.lanceyan.com/)的博客《海量数据相似度计算之 SimHash 和海明距离》）

- **1、分词**，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==> 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1）  内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4）  外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。
- **2、hash**，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为  100101,“51区”通过hash算法计算为  101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。
- **3、加权**，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。
- **4、合并**，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4  -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5”  ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。
- **5、降维**，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的 SimHash 签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。

###  SimHash 签名距离计算

　　我们把库里的文本都转换为 SimHash 签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个 SimHash 的相似度呢？难道是比较两个 SimHash 的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming  distance）就可以计算出两个 SimHash 到底相似不相似。两个 SimHash 对应二进制（01串）取值不同的数量称为这两个 SimHash 的海明距离。举例如下： **1**01**01** 和 **0**01**10** 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。